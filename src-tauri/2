
use matrix_sdk::{authentication::matrix::MatrixSession, config::SyncSettings};
use url::Url;
use tauri::{
    AppHandle, Manager, State, async_runtime::{block_on}
};

use crate::{AppData, types::{auth::AuthState, error::AuthError}};

pub async fn handle_sso_callback(
    state: &State<'_, AppData>,
    url: Url,
) -> Result<MatrixSession, AuthError> {
    let client = state
        .client
        .read()
        .await
        .clone()
        .ok_or(AuthError::MissingClient)?;
    let login_builder = client.matrix_auth().login_with_sso_callback(url)?;
    let response = login_builder.await?;
    println!("Login Success! Here is the response: {response:?}");
    let session = client
        .matrix_auth()
        .session()
        .ok_or(AuthError::MissingSession)?;
    Ok(session)
}

pub async fn finish_login(app_handle: AppHandle) {
    let state: State<'_, AppData> = app_handle.state();
    {
        let mut auth_state = state.state.write().await;
        *auth_state = AuthState::Complete;
    }
    // TODO: emit login success event to the frontend

    let app_handle = app_handle.clone();
    std::thread::spawn(move || {
        let state: State<'_, AppData> = app_handle.state();
        let client = {
            let guard = state.client.blocking_read();
            guard.clone()
        };
        if let Some(client) = client {
            block_on(async move {
                // TODO: Handle this in its own rust module
                println!("Starting sync");
                client.sync(SyncSettings::default()).await.unwrap();
                println!("Sync stopped");
            });
        } else {
            // FIXME: Remove this
            unreachable!();
        }
    });
}

/// In debug builds, spin up a one-shot localhost HTTP server to receive the SSO
/// callback instead of relying on deep links (which require a bundled .app on macOS).
#[cfg(all(debug_assertions, target_os = "macos"))]
pub fn spawn_localhost_sso_handler(listener: std::net::TcpListener, port: u16, app_handle: AppHandle) {
    std::thread::spawn(move || {
        let mut stream = match listener.accept() {
            Ok((stream, _)) => stream,
            Err(e) => {
                eprintln!("SSO callback server error: {e}");
                return;
            }
        };

        let mut buf = [0u8; 4096];
        let n = match std::io::Read::read(&mut stream, &mut buf) {
            Ok(n) => n,
            Err(e) => {
                eprintln!("Failed to read SSO callback request: {e}");
                return;
            }
        };
        let request = String::from_utf8_lossy(&buf[..n]);

        // Parse "GET /?loginToken=xxx HTTP/1.1"
        let path = request
            .lines()
            .next()
            .and_then(|line| line.split_whitespace().nth(1))
            .unwrap_or("/");

        let callback_url = format!("http://localhost:{port}{path}");

        let body = "<html><body><h1>Login successful!</h1><p>You can close this tab and return to the app.</p></body></html>";
        let response = format!(
            "HTTP/1.1 200 OK\r\nContent-Type: text/html\r\nContent-Length: {}\r\nConnection: close\r\n\r\n{}",
            body.len(),
            body,
        );
        let _ = std::io::Write::write_all(&mut stream, response.as_bytes());
        drop(stream);

        if let Ok(url) = Url::parse(&callback_url) {
            block_on(process_sso_redirect(app_handle, url));
        } else {
            eprintln!("Failed to parse SSO callback URL: {callback_url}");
        }
    });
}
